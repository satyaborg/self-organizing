import numpy as np

class Handcrafted(object):
    """All handcrafted architecture definitions
    returns
    locs: contains locations of the encoding
    topology: contains receptive field locations for each arch 
    """
    def __init__(self, dataset: str="MNIST", n_units: int=3):
        self.dataset = dataset
        self.n_units = n_units

    def get_topology(self):
        """Get the manual topologies"""
        topology = []
        archs = {}
        cifar_factor = 16/10 # as used by KP

        if self.n_units == 3: # Type-A topologies
            h, w = 20, 40
            # location of encodings on the map
            locs = [[(0,10),(20,30)],[(10,20),(20,30)],[(0,10),(30,40)]]

            # MNIST
            archs = dict(
                flat=[[(0,20),(0,10)],[(0,10),(0,20)],[(0,20),(10,20)]],
                columnar=[[(0,20),(5,15)],[(0,10),(20,30)],[(10,20),(20,30)]],
                pyramidal=[[(0,20),(0,10)],[(0,20),(10,20)],[(0,20),(20,30)]],
                random1=[[(5, 15), (0, 20)], [(0, 10), (15, 35)], [(5, 15), (15, 35)]],
                random2=[[(0, 20), (15, 25)], [(0, 10), (5, 25)], [(0, 20), (15, 25)]],
                random3=[[(4, 14), (10, 30)], [(0, 10), (15, 35)], [(0, 20), (15, 25)]]
            )
            
        elif self.n_units == 5: # Type-B
            h, w = 20, 50
            # location of encodings on the map
            locs = [[(0,10),(20,30)],[(10,20),(20,30)],[(0,10),(30,40)],[(10,20),(30,40)],[(0,10),(40,50)]]

            # MNIST
            archs = dict(
                flat=[[(0,10),(0,20)],[(0,20),(0,10)],[(10,20),(0,20)],[(10,20),(0,20)],[(0,20),(10,20)]],
                x_shaped=[[(0,20),(0,10)],[(0,20),(10,20)],[(0,20),(20,30)],[(0,10),(30,40)],[(0,10),(30,40)]],
                columnar=[[(0,20),(5,15)],[(0,10),(20,30)],[(10,20),(20,30)],[(0,10),(30,40)],[(10,20),(30,40)]],
                inverted_y=[[(0,20),(0,10)],[(0,20),(10,20)],[(0,20),(20,30)],[(0,10),(30,40)],[(10,20),(30,40)]],
                asymmetric_pyramidal=[[(0,20),(0,10)],[(0,10),(0,20)],[(0,20),(10,20)],[(0,20),(20,30)],[(0,20),(30,40)]],
                random1=[[(0,20),(5,15)],[(5,15),(10,30)],[(0,20),(25,35)],[(5,15),(10,30)],[(10,20),(30,50)]],
                random2=[[(5,15),(15,35)],[(0,10),(20,40)],[(0,20),(5,15)],[(10,20),(30,50)],[(5,15),(20,40)]],
                random3=[[(0,10),(15,35)],[(5,15),(10,30)],[(10,20),(30,50)],[(0,20),(25,35)],[(10,20),(30,40)]]
            )

        elif self.n_units == 7:
            h, w = 20, 60
            # location of encodings on the map
            locs = [[(0,10),(20,30)],
                    [(10,20),(20,30)],
                    [(0,10),(30,40)],
                    [(10,20),(30,40)],
                    [(0,10),(40,50)],
                    [(10,20),(40,50)],
                    [(0,10),(50,60)]
                    ]
            archs = dict(
                flat=[[(0,10),(0,20)],
                                    [(0,20),(10,20)],
                                    [(10,20),(0,20)],
                                    [(0,20),(10,20)],
                                    [(0,20),(0,10)],
                                    [(10,20),(0,20)],
                                    [(0,20),(0,10)]
                                    ],
                columnar=[[(0,20),(5,15)],
                                    [(0,10),(20,30)],
                                    [(10,20),(20,30)],
                                    [(0,10),(30,40)],
                                    [(10,20),(30,40)],
                                    [(0,10),(40,50)],
                                    [(10,20),(40,50)]
                                    ],
                symmetric_pyramidal=[[(0,20),(0,10)],
                                    [(0,10),(0,20)],
                                    [(0,20),(10,20)],
                                    [(10,20),(0,20)],
                                    [(0,20),(20,30)],
                                    [(0,20),(30,40)],
                                    [(0,20),(40,50)]
                                    ],
                asymmetric_pyramidal=[[(0,20),(0,10)],
                                    [(0,10),(0,20)],
                                    [(0,20),(10,20)],
                                    [(10,20),(0,20)],
                                    [(0,20),(20,30)],
                                    [(0,10),(30,50)],
                                    [(10,20),(30,50)]
                                    ],
                semi_x=[[(0,20),(0,10)],
                                    [(0,20),(10,20)],
                                    [(0,20),(20,30)],
                                    [(0,10),(30,40)],
                                    [(10,20),(30,40)],
                                    [(0,10),(40,50)],
                                    [(0,10),(40,50)]
                                    ],
                inverted_y=[[(0,20),(0,10)],
                                    [(0,20),(10,20)],
                                    [(0,20),(20,30)],
                                    [(0,10),(30,40)],
                                    [(10,20),(30,40)],
                                    [(0,10),(40,50)],
                                    [(10,20),(40,50)]
                                    ],
                inverted_tuning_fork=[[(0,20),(0,10)],
                                    [(0,20),(10,20)],
                                    [(0,10),(20,30)],
                                    [(10,20),(20,30)],
                                    [(0,20),(30,40)],
                                    [(0,10),(40,50)],
                                    [(10,20),(40,50)]
                                    ],
                inverted_u=[[(0,20),(0,10)],
                                    [(0,20),(10,20)],
                                    [(0,10),(20,30)],
                                    [(10,20),(20,30)],
                                    [(0,10),(30,40)],
                                    [(10,20),(30,40)],
                                    [(0,20),(40,50)]
                                    ],
                semi_columnar=[[(0,20),(0,10)],
                                    [(0,20),(10,20)],
                                    [(10,20),(0,20)],
                                    [(0,10),(20,30)],
                                    [(10,20),(20,40)],
                                    [(0,10),(30,50)],
                                    [(10,20),(40,50)]
                                    ],
                random1=[[(0,10),(35,55)],
                                    [(0,20),(45,55)],
                                    [(10,20),(12,32)],
                                    [(10,20),(4,24)],
                                    [(10,20),(35,55)],
                                    [(5,15),(30,50)],
                                    [(0,20),(15,25)]
                                    ],
                random2=[[(5,15),(35,55)],
                                    [(10,20),(10,30)],
                                    [(10,20),(0,20)],
                                    [(5,15),(35,55)],
                                    [(0,20),(10,20)],
                                    [(5,15),(20,40)],
                                    [(10,20),(35,45)]
                                    ],
                random3=[[(5,15),(25,45)],
                                    [(0,20),(35,45)],
                                    [(10,20),(30,50)],
                                    [(10,20),(40,60)],
                                    [(10,20),(25,45)],
                                    [(0,10),(10,30)],
                                    [(10,20),(40,60)]
                                    ]
            )
        # for CIFAR10
        if self.dataset == "CIFAR10":
            # convert original locs of MNIST to locs of CIFAR, by multiplying factor cifar_factor.
            locs = (np.array(locs) * cifar_factor).astype(int).tolist()
            archs = { name : (np.array(rf)*cifar_factor).astype(int).tolist() for name, rf in archs.items() }
            h, w = int(h * cifar_factor), int(w * cifar_factor)

        topology = [{"arch" : i+1, 
                    "name" : name,
                    "rfs" : rf 
                    } for i, (name, rf) in enumerate(archs.items())]
        return locs, topology, h, w